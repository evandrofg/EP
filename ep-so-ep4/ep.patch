Os arquivos binários xv6.orig/bootother e xv6/bootother são diferentes
Os arquivos binários xv6.orig/bootother.out e xv6/bootother.out são diferentes
diff -uNr xv6.orig/cat.c xv6/cat.c
--- xv6.orig/cat.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/cat.c	2011-12-04 16:26:40.000000000 -0200
@@ -28,7 +28,7 @@
   }
 
   for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
+    if((fd = open(argv[i], 0, 0)) < 0){
       printf(1, "cat: cannot open %s\n", argv[i]);
       exit();
     }
diff -uNr xv6.orig/defs.h xv6/defs.h
--- xv6.orig/defs.h	2011-02-28 11:32:48.000000000 -0300
+++ xv6/defs.h	2011-12-04 16:49:02.000000000 -0200
@@ -44,6 +44,7 @@
 void            iupdate(struct inode*);
 int             namecmp(const char*, const char*);
 struct inode*   namei(char*);
+struct inode*   nameinofollow(char*);
 struct inode*   nameiparent(char*, char*);
 int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
diff -uNr xv6.orig/fs.c xv6/fs.c
--- xv6.orig/fs.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/fs.c	2011-12-04 17:50:05.000000000 -0200
@@ -565,12 +565,18 @@
 // If parent != 0, return the inode for the parent and copy the final
 // path element into name, which must have room for DIRSIZ bytes.
 static struct inode*
-namex(char *path, int nameiparent, char *name)
+namex(char *path, int nameiparent, char *name, struct inode *root, int depth, int recur)
 {
   struct inode *ip, *next;
+  char buf[100], tname[DIRSIZ];
+
+  if(depth > 10)
+    return 0;
 
   if(*path == '/')
     ip = iget(ROOTDEV, ROOTINO);
+  else if(root)
+    ip = idup(root);
   else
     ip = idup(proc->cwd);
 
@@ -589,7 +595,30 @@
       iunlockput(ip);
       return 0;
     }
-    iunlockput(ip);
+
+    /* Segue recursivamente para encontrar o path de um link simbolico */
+    if(recur==1){
+      iunlock(ip);
+      ilock(next);
+      if(next->type == T_SYMLINK){
+        if(next->size >= sizeof(buf) || readi(next, buf, 0, next->size) != next->size){
+          iunlockput(next);
+          iput(ip);
+          return 0;
+        }
+        buf[next->size] = 0;
+        iunlockput(next);
+        next = namex(buf, 0, tname, ip, depth+1, 1);
+      }
+      else
+        iunlock(next);
+
+      iput(ip);
+    }
+
+    /* Caso nao queira varrer um link */
+    else 
+      iunlockput(ip);
     ip = next;
   }
   if(nameiparent){
@@ -603,11 +632,18 @@
 namei(char *path)
 {
   char name[DIRSIZ];
-  return namex(path, 0, name);
+  return namex(path, 0, name, 0, 0, 1);
+}
+
+struct inode*
+nameinofollow(char *path)
+{
+  char name[DIRSIZ];
+  return namex(path, 0, name, 0, 0, 0);
 }
 
 struct inode*
 nameiparent(char *path, char *name)
 {
-  return namex(path, 1, name);
+  return namex(path, 1, name, 0, 0, 1);
 }
diff -uNr xv6.orig/grep.c xv6/grep.c
--- xv6.orig/grep.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/grep.c	2011-12-04 16:26:52.000000000 -0200
@@ -52,7 +52,7 @@
   }
 
   for(i = 2; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
+    if((fd = open(argv[i], 0,0)) < 0){
       printf(1, "grep: cannot open %s\n", argv[i]);
       exit();
     }
diff -uNr xv6.orig/init.c xv6/init.c
--- xv6.orig/init.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/init.c	2011-12-04 16:27:13.000000000 -0200
@@ -12,9 +12,9 @@
 {
   int pid, wpid;
 
-  if(open("console", O_RDWR) < 0){
+  if(open("console", O_RDWR, 0) < 0){
     mknod("console", 1, 1);
-    open("console", O_RDWR);
+    open("console", O_RDWR, 0);
   }
   dup(0);  // stdout
   dup(0);  // stderr
Os arquivos binários xv6.orig/initcode e xv6/initcode são diferentes
Os arquivos binários xv6.orig/initcode.out e xv6/initcode.out são diferentes
diff -uNr xv6.orig/ln.c xv6/ln.c
--- xv6.orig/ln.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/ln.c	2011-12-04 15:45:35.000000000 -0200
@@ -5,11 +5,26 @@
 int
 main(int argc, char *argv[])
 {
-  if(argc != 3){
-    printf(2, "Usage: ln old new\n");
+  if(argc != 3 && argc != 4){
+    printf(2, "Usage: ln [-s] old new\n");
     exit();
   }
-  if(link(argv[1], argv[2]) < 0)
-    printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+  if ((argc == 3) && (!strcmp(argv[1],"-s"))){
+    printf(2, "Usage: ln [-s] old new\n");
+    exit();
+  }
+  if ((argc == 4) && (strcmp(argv[1],"-s"))){
+    printf(2, "Usage: ln [-s] old new\n");
+    exit();
+  }
+
+  if (argc == 3)
+    if(link(argv[1], argv[2], 1) < 0)
+      printf(2, "link %s %s: failed\n", argv[1], argv[2]);
+
+  if (argc == 4)
+    if(link(argv[2], argv[3], 0) < 0)
+      printf(2, "link %s %s: failed\n", argv[2], argv[3]);
+
   exit();
 }
diff -uNr xv6.orig/ls.c xv6/ls.c
--- xv6.orig/ls.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/ls.c	2011-12-04 18:51:29.057706881 -0200
@@ -2,6 +2,8 @@
 #include "stat.h"
 #include "user.h"
 #include "fs.h"
+/* Não usamos a flag corretamente... */
+#define O_NOFOLLOW 1
 
 char*
 fmtname(char *path)
@@ -25,12 +27,12 @@
 void
 ls(char *path)
 {
-  char buf[512], *p;
-  int fd;
+  char buf[512], buf_symlink[512], *p;
+  int fd, fd_symlink, n;
   struct dirent de;
   struct stat st;
   
-  if((fd = open(path, 0)) < 0){
+  if((fd = open(path, 0, O_NOFOLLOW)) < 0){
     printf(2, "ls: cannot open %s\n", path);
     return;
   }
@@ -45,6 +47,14 @@
   case T_FILE:
     printf(1, "%s %d %d %d\n", fmtname(path), st.type, st.ino, st.size);
     break;
+
+  case T_SYMLINK:
+    printf(1, "%s %d %d %d -> ", fmtname(path), st.type, st.ino, st.size);
+    fd_symlink = open(path, 0, O_NOFOLLOW);
+    while((n = read(fd_symlink, buf_symlink, sizeof(buf_symlink))) > 0)
+      write(1, buf_symlink, n);
+    printf(1,"\n");
+    break;
   
   case T_DIR:
     if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
@@ -63,7 +73,15 @@
         printf(1, "ls: cannot stat %s\n", buf);
         continue;
       }
-      printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
+      if (st.type == T_SYMLINK){
+        printf(1, "%s %d %d %d -> ", fmtname(buf), st.type, st.ino, st.size);
+        fd_symlink = open(buf, 0, O_NOFOLLOW);
+        while((n = read(fd_symlink, buf_symlink, sizeof(buf_symlink))) > 0)
+          write(1, buf_symlink, n);
+        printf(1,"\n");
+      }
+      else if (st.type != T_SYMLINK)
+        printf(1, "%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
     }
     break;
   }
diff -uNr xv6.orig/sh.c xv6/sh.c
--- xv6.orig/sh.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/sh.c	2011-12-04 16:28:07.000000000 -0200
@@ -82,7 +82,7 @@
   case REDIR:
     rcmd = (struct redircmd*)cmd;
     close(rcmd->fd);
-    if(open(rcmd->file, rcmd->mode) < 0){
+    if(open(rcmd->file, rcmd->mode, 0) < 0){
       printf(2, "open %s failed\n", rcmd->file);
       exit();
     }
@@ -148,7 +148,7 @@
   int fd;
   
   // Assumes three file descriptors open.
-  while((fd = open("console", O_RDWR)) >= 0){
+  while((fd = open("console", O_RDWR, 0)) >= 0){
     if(fd >= 3){
       close(fd);
       break;
diff -uNr xv6.orig/stat.h xv6/stat.h
--- xv6.orig/stat.h	2011-02-28 11:32:48.000000000 -0300
+++ xv6/stat.h	2011-12-04 15:44:03.000000000 -0200
@@ -1,6 +1,7 @@
 #define T_DIR  1   // Directory
 #define T_FILE 2   // File
 #define T_DEV  3   // Special device
+#define T_SYMLINK 4 // Symbolic link
 
 struct stat {
   short type;  // Type of file
diff -uNr xv6.orig/stressfs.c xv6/stressfs.c
--- xv6.orig/stressfs.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/stressfs.c	2011-12-04 16:28:20.000000000 -0200
@@ -26,7 +26,7 @@
   printf(1, "%d\n", i);
 
   path[8] += i;
-  fd = open(path, O_CREATE | O_RDWR);
+  fd = open(path, O_CREATE | O_RDWR, 0);
   for(i = 0; i < 100; i++)
     printf(fd, "%d\n", i);
   close(fd);
diff -uNr xv6.orig/sysfile.c xv6/sysfile.c
--- xv6.orig/sysfile.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/sysfile.c	2011-12-04 17:08:18.000000000 -0200
@@ -105,45 +105,6 @@
   return filestat(f, st);
 }
 
-// Create the path new as a link to the same inode as old.
-int
-sys_link(void)
-{
-  char name[DIRSIZ], *new, *old;
-  struct inode *dp, *ip;
-
-  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
-    return -1;
-  if((ip = namei(old)) == 0)
-    return -1;
-  ilock(ip);
-  if(ip->type == T_DIR){
-    iunlockput(ip);
-    return -1;
-  }
-  ip->nlink++;
-  iupdate(ip);
-  iunlock(ip);
-
-  if((dp = nameiparent(new, name)) == 0)
-    goto bad;
-  ilock(dp);
-  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
-    iunlockput(dp);
-    goto bad;
-  }
-  iunlockput(dp);
-  iput(ip);
-  return 0;
-
-bad:
-  ilock(ip);
-  ip->nlink--;
-  iupdate(ip);
-  iunlockput(ip);
-  return -1;
-}
-
 // Is the directory dp empty except for "." and ".." ?
 static int
 isdirempty(struct inode *dp)
@@ -253,22 +214,101 @@
   return ip;
 }
 
+// Create the path new as a link to the same inode as old.
+int
+sys_link(void)
+{
+  char name[DIRSIZ], *new, *old;
+  struct inode *dp, *ip;
+  int linktype;
+
+  /* Link type: 1 = hard link
+                0 = soft link
+   */
+  if(argint(2, &linktype) < 0)
+    return -1;
+
+  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+    return -1;
+  if((ip = namei(old)) == 0)
+    return -1;
+
+  /* Criacao de hard links */
+  if (linktype != 0){
+
+    ilock(ip);
+    if(ip->type == T_DIR){
+      iunlockput(ip);
+      return -1;
+    }
+
+    ip->nlink++;
+    iupdate(ip);
+    iunlock(ip);
+
+    if((dp = nameiparent(new, name)) == 0)
+      goto bad;
+    ilock(dp);
+    if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+      iunlockput(dp);
+      goto bad;
+    }
+    iunlockput(dp);
+    iput(ip);
+
+    return 0;
+  }
+
+  /* Criacao de soft links */
+  if (linktype == 0){
+
+    /* Criar um inode de tipo T_SYMLINK */
+    if((ip = create(new, T_SYMLINK, 0, 0)) == 0)
+      return -1;
+
+    /* Escrever o endereço do link (old) no bloco do inode */
+    writei(ip, old, 0, strlen(old));
+
+    iunlockput(ip);
+
+    return 0;
+  }
+
+bad:
+  ilock(ip);
+  ip->nlink--;
+  iupdate(ip);
+  iunlockput(ip);
+  return -1;
+}
+
 int
 sys_open(void)
 {
   char *path;
   int fd, omode;
+  int o_nofollow;
   struct file *f;
   struct inode *ip;
 
-  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+  if(argstr(0, &path) < 0 || argint(1, &omode) < 0 || argint(2, &o_nofollow) < 0)
     return -1;
+
   if(omode & O_CREATE){
     if((ip = create(path, T_FILE, 0, 0)) == 0)
       return -1;
-  } else {
-    if((ip = namei(path)) == 0)
-      return -1;
+  }
+  else {
+    /* Usa o argumento para seguir ou não os links simbólicos */
+    if(o_nofollow == 0){
+      if((ip = namei(path)) == 0)
+        return -1;
+    }
+    else{
+      if((ip = nameinofollow(path)) == 0)
+        return -1;
+    }
+
     ilock(ip);
     if(ip->type == T_DIR && omode != O_RDONLY){
       iunlockput(ip);
diff -uNr xv6.orig/ulib.c xv6/ulib.c
--- xv6.orig/ulib.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/ulib.c	2011-12-04 16:26:26.000000000 -0200
@@ -73,7 +73,7 @@
   int fd;
   int r;
 
-  fd = open(n, O_RDONLY);
+  fd = open(n, O_RDONLY, 0);
   if(fd < 0)
     return -1;
   r = fstat(fd, st);
diff -uNr xv6.orig/user.h xv6/user.h
--- xv6.orig/user.h	2011-02-28 11:32:48.000000000 -0300
+++ xv6/user.h	2011-12-04 18:50:57.536706305 -0200
@@ -10,11 +10,11 @@
 int close(int);
 int kill(int);
 int exec(char*, char**);
-int open(char*, int);
+int open(char*, int, int);
 int mknod(char*, short, short);
 int unlink(char*);
 int fstat(int fd, struct stat*);
-int link(char*, char*);
+int link(char*, char*, int);
 int mkdir(char*);
 int chdir(char*);
 int dup(int);
diff -uNr xv6.orig/usertests.c xv6/usertests.c
--- xv6.orig/usertests.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/usertests.c	2011-12-04 18:30:08.000000000 -0200
@@ -19,13 +19,13 @@
   int fd;
 
   printf(stdout, "open test\n");
-  fd = open("echo", 0);
+  fd = open("echo", 0, 0);
   if(fd < 0){
     printf(stdout, "open echo failed!\n");
     exit();
   }
   close(fd);
-  fd = open("doesnotexist", 0);
+  fd = open("doesnotexist", 0, 0);
   if(fd >= 0){
     printf(stdout, "open doesnotexist succeeded!\n");
     exit();
@@ -40,7 +40,7 @@
   int i;
 
   printf(stdout, "small file test\n");
-  fd = open("small", O_CREATE|O_RDWR);
+  fd = open("small", O_CREATE|O_RDWR, 0);
   if(fd >= 0){
     printf(stdout, "creat small succeeded; ok\n");
   } else {
@@ -59,7 +59,7 @@
   }
   printf(stdout, "writes ok\n");
   close(fd);
-  fd = open("small", O_RDONLY);
+  fd = open("small", O_RDONLY, 0);
   if(fd >= 0){
     printf(stdout, "open small succeeded ok\n");
   } else {
@@ -89,7 +89,7 @@
 
   printf(stdout, "big files test\n");
 
-  fd = open("big", O_CREATE|O_RDWR);
+  fd = open("big", O_CREATE|O_RDWR, 0);
   if(fd < 0){
     printf(stdout, "error: creat big failed!\n");
     exit();
@@ -105,7 +105,7 @@
 
   close(fd);
 
-  fd = open("big", O_RDONLY);
+  fd = open("big", O_RDONLY, 0);
   if(fd < 0){
     printf(stdout, "error: open big failed!\n");
     exit();
@@ -150,7 +150,7 @@
   name[2] = '\0';
   for(i = 0; i < 52; i++){
     name[1] = '0' + i;
-    fd = open(name, O_CREATE|O_RDWR);
+    fd = open(name, O_CREATE|O_RDWR, 0);
     close(fd);
   }
   name[0] = 'a';
@@ -364,7 +364,7 @@
   char buf[10];
 
   unlink("sharedfd");
-  fd = open("sharedfd", O_CREATE|O_RDWR);
+  fd = open("sharedfd", O_CREATE|O_RDWR, 0);
   if(fd < 0){
     printf(1, "fstests: cannot open sharedfd for writing");
     return;
@@ -382,7 +382,7 @@
   else
     wait();
   close(fd);
-  fd = open("sharedfd", 0);
+  fd = open("sharedfd", 0, 0);
   if(fd < 0){
     printf(1, "fstests: cannot open sharedfd for reading\n");
     return;
@@ -424,7 +424,7 @@
   }
 
   fname = pid ? "f1" : "f2";
-  fd = open(fname, O_CREATE | O_RDWR);
+  fd = open(fname, O_CREATE | O_RDWR, 0);
   if(fd < 0){
     printf(1, "create failed\n");
     exit();
@@ -444,7 +444,7 @@
     exit();
 
   for(i = 0; i < 2; i++){
-    fd = open(i?"f1":"f2", 0);
+    fd = open(i?"f1":"f2", 0, 0);
     total = 0;
     while((n = read(fd, buf, sizeof(buf))) > 0){
       for(j = 0; j < n; j++){
@@ -487,7 +487,7 @@
   name[2] = '\0';
   for(i = 0; i < N; i++){
     name[1] = '0' + i;
-    fd = open(name, O_CREATE | O_RDWR);
+    fd = open(name, O_CREATE | O_RDWR, 0);
     if(fd < 0){
       printf(1, "create failed\n");
       exit();
@@ -510,7 +510,7 @@
   for(i = 0; i < N; i++){
     name[0] = 'p';
     name[1] = '0' + i;
-    fd = open(name, 0);
+    fd = open(name, 0, 0);
     if((i == 0 || i >= N/2) && fd < 0){
       printf(1, "oops createdelete %s didn't exist\n", name);
       exit();
@@ -523,7 +523,7 @@
 
     name[0] = 'c';
     name[1] = '0' + i;
-    fd = open(name, 0);
+    fd = open(name, 0, 0);
     if((i == 0 || i >= N/2) && fd < 0){
       printf(1, "oops createdelete %s didn't exist\n", name);
       exit();
@@ -553,7 +553,7 @@
   int fd, fd1;
 
   printf(1, "unlinkread test\n");
-  fd = open("unlinkread", O_CREATE | O_RDWR);
+  fd = open("unlinkread", O_CREATE | O_RDWR, 0);
   if(fd < 0){
     printf(1, "create unlinkread failed\n");
     exit();
@@ -561,7 +561,7 @@
   write(fd, "hello", 5);
   close(fd);
 
-  fd = open("unlinkread", O_RDWR);
+  fd = open("unlinkread", O_RDWR, 0);
   if(fd < 0){
     printf(1, "open unlinkread failed\n");
     exit();
@@ -571,7 +571,7 @@
     exit();
   }
 
-  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+  fd1 = open("unlinkread", O_CREATE | O_RDWR, 0);
   write(fd1, "yyy", 3);
   close(fd1);
 
@@ -602,7 +602,7 @@
   unlink("lf1");
   unlink("lf2");
 
-  fd = open("lf1", O_CREATE|O_RDWR);
+  fd = open("lf1", O_CREATE|O_RDWR, 0);
   if(fd < 0){
     printf(1, "create lf1 failed\n");
     exit();
@@ -613,18 +613,18 @@
   }
   close(fd);
 
-  if(link("lf1", "lf2") < 0){
+  if(link("lf1", "lf2", 1) < 0){
     printf(1, "link lf1 lf2 failed\n");
     exit();
   }
   unlink("lf1");
 
-  if(open("lf1", 0) >= 0){
+  if(open("lf1", 0, 0) >= 0){
     printf(1, "unlinked lf1 but it is still there!\n");
     exit();
   }
 
-  fd = open("lf2", 0);
+  fd = open("lf2", 0, 0);
   if(fd < 0){
     printf(1, "open lf2 failed\n");
     exit();
@@ -635,18 +635,18 @@
   }
   close(fd);
 
-  if(link("lf2", "lf2") >= 0){
+  if(link("lf2", "lf2", 1) >= 0){
     printf(1, "link lf2 lf2 succeeded! oops\n");
     exit();
   }
 
   unlink("lf2");
-  if(link("lf2", "lf1") >= 0){
+  if(link("lf2", "lf1", 1) >= 0){
     printf(1, "link non-existant succeeded! oops\n");
     exit();
   }
 
-  if(link(".", "lf1") >= 0){
+  if(link(".", "lf1", 1) >= 0){
     printf(1, "link . lf1 succeeded! oops\n");
     exit();
   }
@@ -674,11 +674,11 @@
     unlink(file);
     pid = fork();
     if(pid && (i % 3) == 1){
-      link("C0", file);
+      link("C0", file, 1);
     } else if(pid == 0 && (i % 5) == 1){
-      link("C0", file);
+      link("C0", file, 1);
     } else {
-      fd = open(file, O_CREATE | O_RDWR);
+      fd = open(file, O_CREATE | O_RDWR, 0);
       if(fd < 0){
         printf(1, "concreate create %s failed\n", file);
         exit();
@@ -692,7 +692,7 @@
   }
 
   memset(fa, 0, sizeof(fa));
-  fd = open(".", 0);
+  fd = open(".", 0, 0);
   n = 0;
   while(read(fd, &de, sizeof(de)) > 0){
     if(de.inum == 0)
@@ -727,7 +727,7 @@
     }
     if(((i % 3) == 0 && pid == 0) ||
        ((i % 3) == 1 && pid != 0)){
-      fd = open(file, 0);
+      fd = open(file, 0, 0);
       close(fd);
     } else {
       unlink(file);
@@ -751,7 +751,7 @@
   printf(1, "bigdir test\n");
   unlink("bd");
 
-  fd = open("bd", O_CREATE);
+  fd = open("bd", O_CREATE, 0);
   if(fd < 0){
     printf(1, "bigdir create failed\n");
     exit();
@@ -763,7 +763,7 @@
     name[1] = '0' + (i / 64);
     name[2] = '0' + (i % 64);
     name[3] = '\0';
-    if(link("bd", name) != 0){
+    if(link("bd", name, 1) != 0){
       printf(1, "bigdir link failed\n");
       exit();
     }
@@ -797,7 +797,7 @@
     exit();
   }
 
-  fd = open("dd/ff", O_CREATE | O_RDWR);
+  fd = open("dd/ff", O_CREATE | O_RDWR, 0);
   if(fd < 0){
     printf(1, "create dd/ff failed\n");
     exit();
@@ -815,7 +815,7 @@
     exit();
   }
 
-  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR, 0);
   if(fd < 0){
     printf(1, "create dd/dd/ff failed\n");
     exit();
@@ -823,7 +823,7 @@
   write(fd, "FF", 2);
   close(fd);
 
-  fd = open("dd/dd/../ff", 0);
+  fd = open("dd/dd/../ff", 0, 0);
   if(fd < 0){
     printf(1, "open dd/dd/../ff failed\n");
     exit();
@@ -835,7 +835,7 @@
   }
   close(fd);
 
-  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+  if(link("dd/dd/ff", "dd/dd/ffff", 1) != 0){
     printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
     exit();
   }
@@ -844,7 +844,7 @@
     printf(1, "unlink dd/dd/ff failed\n");
     exit();
   }
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+  if(open("dd/dd/ff", O_RDONLY, 0) >= 0){
     printf(1, "open (unlinked) dd/dd/ff succeeded\n");
     exit();
   }
@@ -866,7 +866,7 @@
     exit();
   }
 
-  fd = open("dd/dd/ffff", 0);
+  fd = open("dd/dd/ffff", 0, 0);
   if(fd < 0){
     printf(1, "open dd/dd/ffff failed\n");
     exit();
@@ -877,40 +877,40 @@
   }
   close(fd);
 
-  if(open("dd/dd/ff", O_RDONLY) >= 0){
+  if(open("dd/dd/ff", O_RDONLY, 0) >= 0){
     printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
     exit();
   }
 
-  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+  if(open("dd/ff/ff", O_CREATE|O_RDWR, 0) >= 0){
     printf(1, "create dd/ff/ff succeeded!\n");
     exit();
   }
-  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+  if(open("dd/xx/ff", O_CREATE|O_RDWR, 0) >= 0){
     printf(1, "create dd/xx/ff succeeded!\n");
     exit();
   }
-  if(open("dd", O_CREATE) >= 0){
+  if(open("dd", O_CREATE, 0) >= 0){
     printf(1, "create dd succeeded!\n");
     exit();
   }
-  if(open("dd", O_RDWR) >= 0){
+  if(open("dd", O_RDWR, 0) >= 0){
     printf(1, "open dd rdwr succeeded!\n");
     exit();
   }
-  if(open("dd", O_WRONLY) >= 0){
+  if(open("dd", O_WRONLY, 0) >= 0){
     printf(1, "open dd wronly succeeded!\n");
     exit();
   }
-  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+  if(link("dd/ff/ff", "dd/dd/xx", 1) == 0){
     printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
     exit();
   }
-  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+  if(link("dd/xx/ff", "dd/dd/xx", 1) == 0){
     printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
     exit();
   }
-  if(link("dd/ff", "dd/dd/ffff") == 0){
+  if(link("dd/ff", "dd/dd/ffff", 1) == 0){
     printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
     exit();
   }
@@ -975,7 +975,7 @@
   printf(1, "bigfile test\n");
 
   unlink("bigfile");
-  fd = open("bigfile", O_CREATE | O_RDWR);
+  fd = open("bigfile", O_CREATE | O_RDWR, 0);
   if(fd < 0){
     printf(1, "cannot create bigfile");
     exit();
@@ -989,7 +989,7 @@
   }
   close(fd);
 
-  fd = open("bigfile", 0);
+  fd = open("bigfile", 0, 0);
   if(fd < 0){
     printf(1, "cannot open bigfile\n");
     exit();
@@ -1039,13 +1039,13 @@
     printf(1, "mkdir 12345678901234/123456789012345 failed\n");
     exit();
   }
-  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE, 0);
   if(fd < 0){
     printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
     exit();
   }
   close(fd);
-  fd = open("12345678901234/12345678901234/12345678901234", 0);
+  fd = open("12345678901234/12345678901234/12345678901234", 0, 0);
   if(fd < 0){
     printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
     exit();
@@ -1110,7 +1110,7 @@
 
   printf(1, "dir vs file\n");
 
-  fd = open("dirfile", O_CREATE);
+  fd = open("dirfile", O_CREATE, 0);
   if(fd < 0){
     printf(1, "create dirfile failed\n");
     exit();
@@ -1120,12 +1120,12 @@
     printf(1, "chdir dirfile succeeded!\n");
     exit();
   }
-  fd = open("dirfile/xx", 0);
+  fd = open("dirfile/xx", 0, 0);
   if(fd >= 0){
     printf(1, "create dirfile/xx succeeded!\n");
     exit();
   }
-  fd = open("dirfile/xx", O_CREATE);
+  fd = open("dirfile/xx", O_CREATE, 0);
   if(fd >= 0){
     printf(1, "create dirfile/xx succeeded!\n");
     exit();
@@ -1138,7 +1138,7 @@
     printf(1, "unlink dirfile/xx succeeded!\n");
     exit();
   }
-  if(link("README", "dirfile/xx") == 0){
+  if(link("README", "dirfile/xx", 1) == 0){
     printf(1, "link to dirfile/xx succeeded!\n");
     exit();
   }
@@ -1147,12 +1147,12 @@
     exit();
   }
 
-  fd = open(".", O_RDWR);
+  fd = open(".", O_RDWR, 0);
   if(fd >= 0){
     printf(1, "open . for writing succeeded!\n");
     exit();
   }
-  fd = open(".", 0);
+  fd = open(".", 0, 0);
   if(write(fd, "x", 1) > 0){
     printf(1, "write . succeeded!\n");
     exit();
@@ -1182,11 +1182,11 @@
     }
 
     mkdir("");
-    link("README", "");
-    fd = open("", O_CREATE);
+    link("README", "", 1);
+    fd = open("", O_CREATE, 0);
     if(fd >= 0)
       close(fd);
-    fd = open("xx", O_CREATE);
+    fd = open("xx", O_CREATE, 0);
     if(fd >= 0)
       close(fd);
     unlink("xx");
@@ -1409,7 +1409,7 @@
     wait();
 
     // try to crash the kernel by passing in a bad string pointer
-    if(link("nosuchfile", (char*)p) != -1){
+    if(link("nosuchfile", (char*)p, 1) != -1){
       printf(stdout, "link should not succeed\n");
       exit();
     }
@@ -1466,11 +1466,11 @@
 {
   printf(1, "usertests starting\n");
 
-  if(open("usertests.ran", 0) >= 0){
+  if(open("usertests.ran", 0, 0) >= 0){
     printf(1, "already ran user tests -- rebuild fs.img\n");
     exit();
   }
-  close(open("usertests.ran", O_CREATE));
+  close(open("usertests.ran", O_CREATE, 0));
 
   bigargtest();
   bsstest();
diff -uNr xv6.orig/usertests.c~ xv6/usertests.c~
--- xv6.orig/usertests.c~	1969-12-31 21:00:00.000000000 -0300
+++ xv6/usertests.c~	2011-12-04 16:09:25.000000000 -0200
@@ -0,0 +1,1508 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+
+char buf[2048];
+char name[3];
+char *echoargv[] = { "echo", "ALL", "TESTS", "PASSED", 0 };
+int stdout = 1;
+
+// simple file system tests
+
+void
+opentest(void)
+{
+  int fd;
+
+  printf(stdout, "open test\n");
+  fd = open("echo", 0);
+  if(fd < 0){
+    printf(stdout, "open echo failed!\n");
+    exit();
+  }
+  close(fd);
+  fd = open("doesnotexist", 0);
+  if(fd >= 0){
+    printf(stdout, "open doesnotexist succeeded!\n");
+    exit();
+  }
+  printf(stdout, "open test ok\n");
+}
+
+void
+writetest(void)
+{
+  int fd;
+  int i;
+
+  printf(stdout, "small file test\n");
+  fd = open("small", O_CREATE|O_RDWR);
+  if(fd >= 0){
+    printf(stdout, "creat small succeeded; ok\n");
+  } else {
+    printf(stdout, "error: creat small failed!\n");
+    exit();
+  }
+  for(i = 0; i < 100; i++){
+    if(write(fd, "aaaaaaaaaa", 10) != 10){
+      printf(stdout, "error: write aa %d new file failed\n", i);
+      exit();
+    }
+    if(write(fd, "bbbbbbbbbb", 10) != 10){
+      printf(stdout, "error: write bb %d new file failed\n", i);
+      exit();
+    }
+  }
+  printf(stdout, "writes ok\n");
+  close(fd);
+  fd = open("small", O_RDONLY);
+  if(fd >= 0){
+    printf(stdout, "open small succeeded ok\n");
+  } else {
+    printf(stdout, "error: open small failed!\n");
+    exit();
+  }
+  i = read(fd, buf, 2000);
+  if(i == 2000){
+    printf(stdout, "read succeeded ok\n");
+  } else {
+    printf(stdout, "read failed\n");
+    exit();
+  }
+  close(fd);
+
+  if(unlink("small") < 0){
+    printf(stdout, "unlink small failed\n");
+    exit();
+  }
+  printf(stdout, "small file test ok\n");
+}
+
+void
+writetest1(void)
+{
+  int i, fd, n;
+
+  printf(stdout, "big files test\n");
+
+  fd = open("big", O_CREATE|O_RDWR);
+  if(fd < 0){
+    printf(stdout, "error: creat big failed!\n");
+    exit();
+  }
+
+  for(i = 0; i < MAXFILE; i++){
+    ((int*)buf)[0] = i;
+    if(write(fd, buf, 512) != 512){
+      printf(stdout, "error: write big file failed\n", i);
+      exit();
+    }
+  }
+
+  close(fd);
+
+  fd = open("big", O_RDONLY);
+  if(fd < 0){
+    printf(stdout, "error: open big failed!\n");
+    exit();
+  }
+
+  n = 0;
+  for(;;){
+    i = read(fd, buf, 512);
+    if(i == 0){
+      if(n == MAXFILE - 1){
+        printf(stdout, "read only %d blocks from big", n);
+        exit();
+      }
+      break;
+    } else if(i != 512){
+      printf(stdout, "read failed %d\n", i);
+      exit();
+    }
+    if(((int*)buf)[0] != n){
+      printf(stdout, "read content of block %d is %d\n",
+             n, ((int*)buf)[0]);
+      exit();
+    }
+    n++;
+  }
+  close(fd);
+  if(unlink("big") < 0){
+    printf(stdout, "unlink big failed\n");
+    exit();
+  }
+  printf(stdout, "big files ok\n");
+}
+
+void
+createtest(void)
+{
+  int i, fd;
+
+  printf(stdout, "many creates, followed by unlink test\n");
+
+  name[0] = 'a';
+  name[2] = '\0';
+  for(i = 0; i < 52; i++){
+    name[1] = '0' + i;
+    fd = open(name, O_CREATE|O_RDWR);
+    close(fd);
+  }
+  name[0] = 'a';
+  name[2] = '\0';
+  for(i = 0; i < 52; i++){
+    name[1] = '0' + i;
+    unlink(name);
+  }
+  printf(stdout, "many creates, followed by unlink; ok\n");
+}
+
+void dirtest(void)
+{
+  printf(stdout, "mkdir test\n");
+
+  if(mkdir("dir0") < 0){
+    printf(stdout, "mkdir failed\n");
+    exit();
+  }
+
+  if(chdir("dir0") < 0){
+    printf(stdout, "chdir dir0 failed\n");
+    exit();
+  }
+
+  if(chdir("..") < 0){
+    printf(stdout, "chdir .. failed\n");
+    exit();
+  }
+
+  if(unlink("dir0") < 0){
+    printf(stdout, "unlink dir0 failed\n");
+    exit();
+  }
+  printf(stdout, "mkdir test\n");
+}
+
+void
+exectest(void)
+{
+  printf(stdout, "exec test\n");
+  if(exec("echo", echoargv) < 0){
+    printf(stdout, "exec echo failed\n");
+    exit();
+  }
+}
+
+// simple fork and pipe read/write
+
+void
+pipe1(void)
+{
+  int fds[2], pid;
+  int seq, i, n, cc, total;
+
+  if(pipe(fds) != 0){
+    printf(1, "pipe() failed\n");
+    exit();
+  }
+  pid = fork();
+  seq = 0;
+  if(pid == 0){
+    close(fds[0]);
+    for(n = 0; n < 5; n++){
+      for(i = 0; i < 1033; i++)
+        buf[i] = seq++;
+      if(write(fds[1], buf, 1033) != 1033){
+        printf(1, "pipe1 oops 1\n");
+        exit();
+      }
+    }
+    exit();
+  } else if(pid > 0){
+    close(fds[1]);
+    total = 0;
+    cc = 1;
+    while((n = read(fds[0], buf, cc)) > 0){
+      for(i = 0; i < n; i++){
+        if((buf[i] & 0xff) != (seq++ & 0xff)){
+          printf(1, "pipe1 oops 2\n");
+          return;
+        }
+      }
+      total += n;
+      cc = cc * 2;
+      if(cc > sizeof(buf))
+        cc = sizeof(buf);
+    }
+    if(total != 5 * 1033)
+      printf(1, "pipe1 oops 3 total %d\n", total);
+    close(fds[0]);
+    wait();
+  } else {
+    printf(1, "fork() failed\n");
+    exit();
+  }
+  printf(1, "pipe1 ok\n");
+}
+
+// meant to be run w/ at most two CPUs
+void
+preempt(void)
+{
+  int pid1, pid2, pid3;
+  int pfds[2];
+
+  printf(1, "preempt: ");
+  pid1 = fork();
+  if(pid1 == 0)
+    for(;;)
+      ;
+
+  pid2 = fork();
+  if(pid2 == 0)
+    for(;;)
+      ;
+
+  pipe(pfds);
+  pid3 = fork();
+  if(pid3 == 0){
+    close(pfds[0]);
+    if(write(pfds[1], "x", 1) != 1)
+      printf(1, "preempt write error");
+    close(pfds[1]);
+    for(;;)
+      ;
+  }
+
+  close(pfds[1]);
+  if(read(pfds[0], buf, sizeof(buf)) != 1){
+    printf(1, "preempt read error");
+    return;
+  }
+  close(pfds[0]);
+  printf(1, "kill... ");
+  kill(pid1);
+  kill(pid2);
+  kill(pid3);
+  printf(1, "wait... ");
+  wait();
+  wait();
+  wait();
+  printf(1, "preempt ok\n");
+}
+
+// try to find any races between exit and wait
+void
+exitwait(void)
+{
+  int i, pid;
+
+  for(i = 0; i < 100; i++){
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      return;
+    }
+    if(pid){
+      if(wait() != pid){
+        printf(1, "wait wrong pid\n");
+        return;
+      }
+    } else {
+      exit();
+    }
+  }
+  printf(1, "exitwait ok\n");
+}
+
+void
+mem(void)
+{
+  void *m1, *m2;
+  int pid, ppid;
+
+  printf(1, "mem test\n");
+  ppid = getpid();
+  if((pid = fork()) == 0){
+    m1 = 0;
+    while((m2 = malloc(10001)) != 0){
+      *(char**)m2 = m1;
+      m1 = m2;
+    }
+    while(m1){
+      m2 = *(char**)m1;
+      free(m1);
+      m1 = m2;
+    }
+    m1 = malloc(1024*20);
+    if(m1 == 0){
+      printf(1, "couldn't allocate mem?!!\n");
+      kill(ppid);
+      exit();
+    }
+    free(m1);
+    printf(1, "mem ok\n");
+    exit();
+  } else {
+    wait();
+  }
+}
+
+// More file system tests
+
+// two processes write to the same file descriptor
+// is the offset shared? does inode locking work?
+void
+sharedfd(void)
+{
+  int fd, pid, i, n, nc, np;
+  char buf[10];
+
+  unlink("sharedfd");
+  fd = open("sharedfd", O_CREATE|O_RDWR);
+  if(fd < 0){
+    printf(1, "fstests: cannot open sharedfd for writing");
+    return;
+  }
+  pid = fork();
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+  for(i = 0; i < 1000; i++){
+    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+      printf(1, "fstests: write sharedfd failed\n");
+      break;
+    }
+  }
+  if(pid == 0)
+    exit();
+  else
+    wait();
+  close(fd);
+  fd = open("sharedfd", 0);
+  if(fd < 0){
+    printf(1, "fstests: cannot open sharedfd for reading\n");
+    return;
+  }
+  nc = np = 0;
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+    for(i = 0; i < sizeof(buf); i++){
+      if(buf[i] == 'c')
+        nc++;
+      if(buf[i] == 'p')
+        np++;
+    }
+  }
+  close(fd);
+  unlink("sharedfd");
+  if(nc == 10000 && np == 10000)
+    printf(1, "sharedfd ok\n");
+  else
+    printf(1, "sharedfd oops %d %d\n", nc, np);
+}
+
+// two processes write two different files at the same
+// time, to test block allocation.
+void
+twofiles(void)
+{
+  int fd, pid, i, j, n, total;
+  char *fname;
+
+  printf(1, "twofiles test\n");
+
+  unlink("f1");
+  unlink("f2");
+
+  pid = fork();
+  if(pid < 0){
+    printf(1, "fork failed\n");
+    return;
+  }
+
+  fname = pid ? "f1" : "f2";
+  fd = open(fname, O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "create failed\n");
+    exit();
+  }
+
+  memset(buf, pid?'p':'c', 512);
+  for(i = 0; i < 12; i++){
+    if((n = write(fd, buf, 500)) != 500){
+      printf(1, "write failed %d\n", n);
+      exit();
+    }
+  }
+  close(fd);
+  if(pid)
+    wait();
+  else
+    exit();
+
+  for(i = 0; i < 2; i++){
+    fd = open(i?"f1":"f2", 0);
+    total = 0;
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+      for(j = 0; j < n; j++){
+        if(buf[j] != (i?'p':'c')){
+          printf(1, "wrong char\n");
+          exit();
+        }
+      }
+      total += n;
+    }
+    close(fd);
+    if(total != 12*500){
+      printf(1, "wrong length %d\n", total);
+      exit();
+    }
+  }
+
+  unlink("f1");
+  unlink("f2");
+
+  printf(1, "twofiles ok\n");
+}
+
+// two processes create and delete different files in same directory
+void
+createdelete(void)
+{
+  enum { N = 20 };
+  int pid, i, fd;
+  char name[32];
+
+  printf(1, "createdelete test\n");
+  pid = fork();
+  if(pid < 0){
+    printf(1, "fork failed\n");
+    exit();
+  }
+
+  name[0] = pid ? 'p' : 'c';
+  name[2] = '\0';
+  for(i = 0; i < N; i++){
+    name[1] = '0' + i;
+    fd = open(name, O_CREATE | O_RDWR);
+    if(fd < 0){
+      printf(1, "create failed\n");
+      exit();
+    }
+    close(fd);
+    if(i > 0 && (i % 2 ) == 0){
+      name[1] = '0' + (i / 2);
+      if(unlink(name) < 0){
+        printf(1, "unlink failed\n");
+        exit();
+      }
+    }
+  }
+
+  if(pid==0)
+    exit();
+  else
+    wait();
+
+  for(i = 0; i < N; i++){
+    name[0] = 'p';
+    name[1] = '0' + i;
+    fd = open(name, 0);
+    if((i == 0 || i >= N/2) && fd < 0){
+      printf(1, "oops createdelete %s didn't exist\n", name);
+      exit();
+    } else if((i >= 1 && i < N/2) && fd >= 0){
+      printf(1, "oops createdelete %s did exist\n", name);
+      exit();
+    }
+    if(fd >= 0)
+      close(fd);
+
+    name[0] = 'c';
+    name[1] = '0' + i;
+    fd = open(name, 0);
+    if((i == 0 || i >= N/2) && fd < 0){
+      printf(1, "oops createdelete %s didn't exist\n", name);
+      exit();
+    } else if((i >= 1 && i < N/2) && fd >= 0){
+      printf(1, "oops createdelete %s did exist\n", name);
+      exit();
+    }
+    if(fd >= 0)
+      close(fd);
+  }
+
+  for(i = 0; i < N; i++){
+    name[0] = 'p';
+    name[1] = '0' + i;
+    unlink(name);
+    name[0] = 'c';
+    unlink(name);
+  }
+
+  printf(1, "createdelete ok\n");
+}
+
+// can I unlink a file and still read it?
+void
+unlinkread(void)
+{
+  int fd, fd1;
+
+  printf(1, "unlinkread test\n");
+  fd = open("unlinkread", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "create unlinkread failed\n");
+    exit();
+  }
+  write(fd, "hello", 5);
+  close(fd);
+
+  fd = open("unlinkread", O_RDWR);
+  if(fd < 0){
+    printf(1, "open unlinkread failed\n");
+    exit();
+  }
+  if(unlink("unlinkread") != 0){
+    printf(1, "unlink unlinkread failed\n");
+    exit();
+  }
+
+  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+  write(fd1, "yyy", 3);
+  close(fd1);
+
+  if(read(fd, buf, sizeof(buf)) != 5){
+    printf(1, "unlinkread read failed");
+    exit();
+  }
+  if(buf[0] != 'h'){
+    printf(1, "unlinkread wrong data\n");
+    exit();
+  }
+  if(write(fd, buf, 10) != 10){
+    printf(1, "unlinkread write failed\n");
+    exit();
+  }
+  close(fd);
+  unlink("unlinkread");
+  printf(1, "unlinkread ok\n");
+}
+
+void
+linktest(void)
+{
+  int fd;
+
+  printf(1, "linktest\n");
+
+  unlink("lf1");
+  unlink("lf2");
+
+  fd = open("lf1", O_CREATE|O_RDWR);
+  if(fd < 0){
+    printf(1, "create lf1 failed\n");
+    exit();
+  }
+  if(write(fd, "hello", 5) != 5){
+    printf(1, "write lf1 failed\n");
+    exit();
+  }
+  close(fd);
+
+  if(link("lf1", "lf2", 1) < 0){
+    printf(1, "link lf1 lf2 failed\n");
+    exit();
+  }
+  unlink("lf1");
+
+  if(open("lf1", 0) >= 0){
+    printf(1, "unlinked lf1 but it is still there!\n");
+    exit();
+  }
+
+  fd = open("lf2", 0);
+  if(fd < 0){
+    printf(1, "open lf2 failed\n");
+    exit();
+  }
+  if(read(fd, buf, sizeof(buf)) != 5){
+    printf(1, "read lf2 failed\n");
+    exit();
+  }
+  close(fd);
+
+  if(link("lf2", "lf2", 1) >= 0){
+    printf(1, "link lf2 lf2 succeeded! oops\n");
+    exit();
+  }
+
+  unlink("lf2");
+  if(link("lf2", "lf1", 1) >= 0){
+    printf(1, "link non-existant succeeded! oops\n");
+    exit();
+  }
+
+  if(link(".", "lf1", 1) >= 0){
+    printf(1, "link . lf1 succeeded! oops\n");
+    exit();
+  }
+
+  printf(1, "linktest ok\n");
+}
+
+// test concurrent create and unlink of the same file
+void
+concreate(void)
+{
+  char file[3];
+  int i, pid, n, fd;
+  char fa[40];
+  struct {
+    ushort inum;
+    char name[14];
+  } de;
+
+  printf(1, "concreate test\n");
+  file[0] = 'C';
+  file[2] = '\0';
+  for(i = 0; i < 40; i++){
+    file[1] = '0' + i;
+    unlink(file);
+    pid = fork();
+    if(pid && (i % 3) == 1){
+      link("C0", file, 1);
+    } else if(pid == 0 && (i % 5) == 1){
+      link("C0", file, 1);
+    } else {
+      fd = open(file, O_CREATE | O_RDWR);
+      if(fd < 0){
+        printf(1, "concreate create %s failed\n", file);
+        exit();
+      }
+      close(fd);
+    }
+    if(pid == 0)
+      exit();
+    else
+      wait();
+  }
+
+  memset(fa, 0, sizeof(fa));
+  fd = open(".", 0);
+  n = 0;
+  while(read(fd, &de, sizeof(de)) > 0){
+    if(de.inum == 0)
+      continue;
+    if(de.name[0] == 'C' && de.name[2] == '\0'){
+      i = de.name[1] - '0';
+      if(i < 0 || i >= sizeof(fa)){
+        printf(1, "concreate weird file %s\n", de.name);
+        exit();
+      }
+      if(fa[i]){
+        printf(1, "concreate duplicate file %s\n", de.name);
+        exit();
+      }
+      fa[i] = 1;
+      n++;
+    }
+  }
+  close(fd);
+
+  if(n != 40){
+    printf(1, "concreate not enough files in directory listing\n");
+    exit();
+  }
+
+  for(i = 0; i < 40; i++){
+    file[1] = '0' + i;
+    pid = fork();
+    if(pid < 0){
+      printf(1, "fork failed\n");
+      exit();
+    }
+    if(((i % 3) == 0 && pid == 0) ||
+       ((i % 3) == 1 && pid != 0)){
+      fd = open(file, 0);
+      close(fd);
+    } else {
+      unlink(file);
+    }
+    if(pid == 0)
+      exit();
+    else
+      wait();
+  }
+
+  printf(1, "concreate ok\n");
+}
+
+// directory that uses indirect blocks
+void
+bigdir(void)
+{
+  int i, fd;
+  char name[10];
+
+  printf(1, "bigdir test\n");
+  unlink("bd");
+
+  fd = open("bd", O_CREATE);
+  if(fd < 0){
+    printf(1, "bigdir create failed\n");
+    exit();
+  }
+  close(fd);
+
+  for(i = 0; i < 500; i++){
+    name[0] = 'x';
+    name[1] = '0' + (i / 64);
+    name[2] = '0' + (i % 64);
+    name[3] = '\0';
+    if(link("bd", name, 1) != 0){
+      printf(1, "bigdir link failed\n");
+      exit();
+    }
+  }
+
+  unlink("bd");
+  for(i = 0; i < 500; i++){
+    name[0] = 'x';
+    name[1] = '0' + (i / 64);
+    name[2] = '0' + (i % 64);
+    name[3] = '\0';
+    if(unlink(name) != 0){
+      printf(1, "bigdir unlink failed");
+      exit();
+    }
+  }
+
+  printf(1, "bigdir ok\n");
+}
+
+void
+subdir(void)
+{
+  int fd, cc;
+
+  printf(1, "subdir test\n");
+
+  unlink("ff");
+  if(mkdir("dd") != 0){
+    printf(1, "subdir mkdir dd failed\n");
+    exit();
+  }
+
+  fd = open("dd/ff", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "create dd/ff failed\n");
+    exit();
+  }
+  write(fd, "ff", 2);
+  close(fd);
+  
+  if(unlink("dd") >= 0){
+    printf(1, "unlink dd (non-empty dir) succeeded!\n");
+    exit();
+  }
+
+  if(mkdir("/dd/dd") != 0){
+    printf(1, "subdir mkdir dd/dd failed\n");
+    exit();
+  }
+
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "create dd/dd/ff failed\n");
+    exit();
+  }
+  write(fd, "FF", 2);
+  close(fd);
+
+  fd = open("dd/dd/../ff", 0);
+  if(fd < 0){
+    printf(1, "open dd/dd/../ff failed\n");
+    exit();
+  }
+  cc = read(fd, buf, sizeof(buf));
+  if(cc != 2 || buf[0] != 'f'){
+    printf(1, "dd/dd/../ff wrong content\n");
+    exit();
+  }
+  close(fd);
+
+  if(link("dd/dd/ff", "dd/dd/ffff", 1) != 0){
+    printf(1, "link dd/dd/ff dd/dd/ffff failed\n");
+    exit();
+  }
+
+  if(unlink("dd/dd/ff") != 0){
+    printf(1, "unlink dd/dd/ff failed\n");
+    exit();
+  }
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    printf(1, "open (unlinked) dd/dd/ff succeeded\n");
+    exit();
+  }
+
+  if(chdir("dd") != 0){
+    printf(1, "chdir dd failed\n");
+    exit();
+  }
+  if(chdir("dd/../../dd") != 0){
+    printf(1, "chdir dd/../../dd failed\n");
+    exit();
+  }
+  if(chdir("dd/../../../dd") != 0){
+    printf(1, "chdir dd/../../dd failed\n");
+    exit();
+  }
+  if(chdir("./..") != 0){
+    printf(1, "chdir ./.. failed\n");
+    exit();
+  }
+
+  fd = open("dd/dd/ffff", 0);
+  if(fd < 0){
+    printf(1, "open dd/dd/ffff failed\n");
+    exit();
+  }
+  if(read(fd, buf, sizeof(buf)) != 2){
+    printf(1, "read dd/dd/ffff wrong len\n");
+    exit();
+  }
+  close(fd);
+
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    printf(1, "open (unlinked) dd/dd/ff succeeded!\n");
+    exit();
+  }
+
+  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+    printf(1, "create dd/ff/ff succeeded!\n");
+    exit();
+  }
+  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+    printf(1, "create dd/xx/ff succeeded!\n");
+    exit();
+  }
+  if(open("dd", O_CREATE) >= 0){
+    printf(1, "create dd succeeded!\n");
+    exit();
+  }
+  if(open("dd", O_RDWR) >= 0){
+    printf(1, "open dd rdwr succeeded!\n");
+    exit();
+  }
+  if(open("dd", O_WRONLY) >= 0){
+    printf(1, "open dd wronly succeeded!\n");
+    exit();
+  }
+  if(link("dd/ff/ff", "dd/dd/xx", 1) == 0){
+    printf(1, "link dd/ff/ff dd/dd/xx succeeded!\n");
+    exit();
+  }
+  if(link("dd/xx/ff", "dd/dd/xx", 1) == 0){
+    printf(1, "link dd/xx/ff dd/dd/xx succeeded!\n");
+    exit();
+  }
+  if(link("dd/ff", "dd/dd/ffff", 1) == 0){
+    printf(1, "link dd/ff dd/dd/ffff succeeded!\n");
+    exit();
+  }
+  if(mkdir("dd/ff/ff") == 0){
+    printf(1, "mkdir dd/ff/ff succeeded!\n");
+    exit();
+  }
+  if(mkdir("dd/xx/ff") == 0){
+    printf(1, "mkdir dd/xx/ff succeeded!\n");
+    exit();
+  }
+  if(mkdir("dd/dd/ffff") == 0){
+    printf(1, "mkdir dd/dd/ffff succeeded!\n");
+    exit();
+  }
+  if(unlink("dd/xx/ff") == 0){
+    printf(1, "unlink dd/xx/ff succeeded!\n");
+    exit();
+  }
+  if(unlink("dd/ff/ff") == 0){
+    printf(1, "unlink dd/ff/ff succeeded!\n");
+    exit();
+  }
+  if(chdir("dd/ff") == 0){
+    printf(1, "chdir dd/ff succeeded!\n");
+    exit();
+  }
+  if(chdir("dd/xx") == 0){
+    printf(1, "chdir dd/xx succeeded!\n");
+    exit();
+  }
+
+  if(unlink("dd/dd/ffff") != 0){
+    printf(1, "unlink dd/dd/ff failed\n");
+    exit();
+  }
+  if(unlink("dd/ff") != 0){
+    printf(1, "unlink dd/ff failed\n");
+    exit();
+  }
+  if(unlink("dd") == 0){
+    printf(1, "unlink non-empty dd succeeded!\n");
+    exit();
+  }
+  if(unlink("dd/dd") < 0){
+    printf(1, "unlink dd/dd failed\n");
+    exit();
+  }
+  if(unlink("dd") < 0){
+    printf(1, "unlink dd failed\n");
+    exit();
+  }
+
+  printf(1, "subdir ok\n");
+}
+
+void
+bigfile(void)
+{
+  int fd, i, total, cc;
+
+  printf(1, "bigfile test\n");
+
+  unlink("bigfile");
+  fd = open("bigfile", O_CREATE | O_RDWR);
+  if(fd < 0){
+    printf(1, "cannot create bigfile");
+    exit();
+  }
+  for(i = 0; i < 20; i++){
+    memset(buf, i, 600);
+    if(write(fd, buf, 600) != 600){
+      printf(1, "write bigfile failed\n");
+      exit();
+    }
+  }
+  close(fd);
+
+  fd = open("bigfile", 0);
+  if(fd < 0){
+    printf(1, "cannot open bigfile\n");
+    exit();
+  }
+  total = 0;
+  for(i = 0; ; i++){
+    cc = read(fd, buf, 300);
+    if(cc < 0){
+      printf(1, "read bigfile failed\n");
+      exit();
+    }
+    if(cc == 0)
+      break;
+    if(cc != 300){
+      printf(1, "short read bigfile\n");
+      exit();
+    }
+    if(buf[0] != i/2 || buf[299] != i/2){
+      printf(1, "read bigfile wrong data\n");
+      exit();
+    }
+    total += cc;
+  }
+  close(fd);
+  if(total != 20*600){
+    printf(1, "read bigfile wrong total\n");
+    exit();
+  }
+  unlink("bigfile");
+
+  printf(1, "bigfile test ok\n");
+}
+
+void
+fourteen(void)
+{
+  int fd;
+
+  // DIRSIZ is 14.
+  printf(1, "fourteen test\n");
+
+  if(mkdir("12345678901234") != 0){
+    printf(1, "mkdir 12345678901234 failed\n");
+    exit();
+  }
+  if(mkdir("12345678901234/123456789012345") != 0){
+    printf(1, "mkdir 12345678901234/123456789012345 failed\n");
+    exit();
+  }
+  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+  if(fd < 0){
+    printf(1, "create 123456789012345/123456789012345/123456789012345 failed\n");
+    exit();
+  }
+  close(fd);
+  fd = open("12345678901234/12345678901234/12345678901234", 0);
+  if(fd < 0){
+    printf(1, "open 12345678901234/12345678901234/12345678901234 failed\n");
+    exit();
+  }
+  close(fd);
+
+  if(mkdir("12345678901234/12345678901234") == 0){
+    printf(1, "mkdir 12345678901234/12345678901234 succeeded!\n");
+    exit();
+  }
+  if(mkdir("123456789012345/12345678901234") == 0){
+    printf(1, "mkdir 12345678901234/123456789012345 succeeded!\n");
+    exit();
+  }
+
+  printf(1, "fourteen ok\n");
+}
+
+void
+rmdot(void)
+{
+  printf(1, "rmdot test\n");
+  if(mkdir("dots") != 0){
+    printf(1, "mkdir dots failed\n");
+    exit();
+  }
+  if(chdir("dots") != 0){
+    printf(1, "chdir dots failed\n");
+    exit();
+  }
+  if(unlink(".") == 0){
+    printf(1, "rm . worked!\n");
+    exit();
+  }
+  if(unlink("..") == 0){
+    printf(1, "rm .. worked!\n");
+    exit();
+  }
+  if(chdir("/") != 0){
+    printf(1, "chdir / failed\n");
+    exit();
+  }
+  if(unlink("dots/.") == 0){
+    printf(1, "unlink dots/. worked!\n");
+    exit();
+  }
+  if(unlink("dots/..") == 0){
+    printf(1, "unlink dots/.. worked!\n");
+    exit();
+  }
+  if(unlink("dots") != 0){
+    printf(1, "unlink dots failed!\n");
+    exit();
+  }
+  printf(1, "rmdot ok\n");
+}
+
+void
+dirfile(void)
+{
+  int fd;
+
+  printf(1, "dir vs file\n");
+
+  fd = open("dirfile", O_CREATE);
+  if(fd < 0){
+    printf(1, "create dirfile failed\n");
+    exit();
+  }
+  close(fd);
+  if(chdir("dirfile") == 0){
+    printf(1, "chdir dirfile succeeded!\n");
+    exit();
+  }
+  fd = open("dirfile/xx", 0);
+  if(fd >= 0){
+    printf(1, "create dirfile/xx succeeded!\n");
+    exit();
+  }
+  fd = open("dirfile/xx", O_CREATE);
+  if(fd >= 0){
+    printf(1, "create dirfile/xx succeeded!\n");
+    exit();
+  }
+  if(mkdir("dirfile/xx") == 0){
+    printf(1, "mkdir dirfile/xx succeeded!\n");
+    exit();
+  }
+  if(unlink("dirfile/xx") == 0){
+    printf(1, "unlink dirfile/xx succeeded!\n");
+    exit();
+  }
+  if(link("README", "dirfile/xx", 1) == 0){
+    printf(1, "link to dirfile/xx succeeded!\n");
+    exit();
+  }
+  if(unlink("dirfile") != 0){
+    printf(1, "unlink dirfile failed!\n");
+    exit();
+  }
+
+  fd = open(".", O_RDWR);
+  if(fd >= 0){
+    printf(1, "open . for writing succeeded!\n");
+    exit();
+  }
+  fd = open(".", 0);
+  if(write(fd, "x", 1) > 0){
+    printf(1, "write . succeeded!\n");
+    exit();
+  }
+  close(fd);
+
+  printf(1, "dir vs file OK\n");
+}
+
+// test that iput() is called at the end of _namei()
+void
+iref(void)
+{
+  int i, fd;
+
+  printf(1, "empty file name\n");
+
+  // the 50 is NINODE
+  for(i = 0; i < 50 + 1; i++){
+    if(mkdir("irefd") != 0){
+      printf(1, "mkdir irefd failed\n");
+      exit();
+    }
+    if(chdir("irefd") != 0){
+      printf(1, "chdir irefd failed\n");
+      exit();
+    }
+
+    mkdir("");
+    link("README", "", 1);
+    fd = open("", O_CREATE);
+    if(fd >= 0)
+      close(fd);
+    fd = open("xx", O_CREATE);
+    if(fd >= 0)
+      close(fd);
+    unlink("xx");
+  }
+
+  chdir("/");
+  printf(1, "empty file name OK\n");
+}
+
+// test that fork fails gracefully
+// the forktest binary also does this, but it runs out of proc entries first.
+// inside the bigger usertests binary, we run out of memory first.
+void
+forktest(void)
+{
+  int n, pid;
+
+  printf(1, "fork test\n");
+
+  for(n=0; n<1000; n++){
+    pid = fork();
+    if(pid < 0)
+      break;
+    if(pid == 0)
+      exit();
+  }
+  
+  if(n == 1000){
+    printf(1, "fork claimed to work 1000 times!\n");
+    exit();
+  }
+  
+  for(; n > 0; n--){
+    if(wait() < 0){
+      printf(1, "wait stopped early\n");
+      exit();
+    }
+  }
+  
+  if(wait() != -1){
+    printf(1, "wait got too many\n");
+    exit();
+  }
+  
+  printf(1, "fork test OK\n");
+}
+
+void
+sbrktest(void)
+{
+  int fds[2], pid, pids[32], ppid;
+  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
+  uint amt;
+
+  printf(stdout, "sbrk test\n");
+  oldbrk = sbrk(0);
+
+  // can one sbrk() less than a page?
+  a = sbrk(0);
+  int i;
+  for(i = 0; i < 5000; i++){
+    b = sbrk(1);
+    if(b != a){
+      printf(stdout, "sbrk test failed %d %x %x\n", i, a, b);
+      exit();
+    }
+    *b = 1;
+    a = b + 1;
+  }
+  pid = fork();
+  if(pid < 0){
+    printf(stdout, "sbrk test fork failed\n");
+    exit();
+  }
+  c = sbrk(1);
+  c = sbrk(1);
+  if(c != a + 1){
+    printf(stdout, "sbrk test failed post-fork\n");
+    exit();
+  }
+  if(pid == 0)
+    exit();
+  wait();
+
+  // can one allocate the full 640K?
+  a = sbrk(0);
+  amt = (640 * 1024) - (uint)a;
+  p = sbrk(amt);
+  if(p != a){
+    printf(stdout, "sbrk test failed 640K test, p %x a %x\n", p, a);
+    exit();
+  }
+  lastaddr = (char*)(640 * 1024 - 1);
+  *lastaddr = 99;
+
+  // is one forbidden from allocating more than 640K?
+  c = sbrk(4096);
+  if(c != (char*)0xffffffff){
+    printf(stdout, "sbrk allocated more than 640K, c %x\n", c);
+    exit();
+  }
+
+  // can one de-allocate?
+  a = sbrk(0);
+  c = sbrk(-4096);
+  if(c == (char*)0xffffffff){
+    printf(stdout, "sbrk could not deallocate\n");
+    exit();
+  }
+  c = sbrk(0);
+  if(c != a - 4096){
+    printf(stdout, "sbrk deallocation produced wrong address, a %x c %x\n", a, c);
+    exit();
+  }
+
+  // can one re-allocate that page?
+  a = sbrk(0);
+  c = sbrk(4096);
+  if(c != a || sbrk(0) != a + 4096){
+    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
+    exit();
+  }
+  if(*lastaddr == 99){
+    // should be zero
+    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
+    exit();
+  }
+
+  c = sbrk(4096);
+  if(c != (char*)0xffffffff){
+    printf(stdout, "sbrk was able to re-allocate beyond 640K, c %x\n", c);
+    exit();
+  }
+
+  // can we read the kernel's memory?
+  for(a = (char*)(640*1024); a < (char*)2000000; a += 50000){
+    ppid = getpid();
+    pid = fork();
+    if(pid < 0){
+      printf(stdout, "fork failed\n");
+      exit();
+    }
+    if(pid == 0){
+      printf(stdout, "oops could read %x = %x\n", a, *a);
+      kill(ppid);
+      exit();
+    }
+    wait();
+  }
+
+  // if we run the system out of memory, does it clean up the last
+  // failed allocation?
+  sbrk(-(sbrk(0) - oldbrk));
+  if(pipe(fds) != 0){
+    printf(1, "pipe() failed\n");
+    exit();
+  }
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    if((pids[i] = fork()) == 0){
+      // allocate the full 640K
+      sbrk((640 * 1024) - (uint)sbrk(0));
+      write(fds[1], "x", 1);
+      // sit around until killed
+      for(;;) sleep(1000);
+    }
+    if(pids[i] != -1)
+      read(fds[0], &scratch, 1);
+  }
+  // if those failed allocations freed up the pages they did allocate,
+  // we'll be able to allocate here
+  c = sbrk(4096);
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    if(pids[i] == -1)
+      continue;
+    kill(pids[i]);
+    wait();
+  }
+  if(c == (char*)0xffffffff){
+    printf(stdout, "failed sbrk leaked memory\n");
+    exit();
+  }
+
+  if(sbrk(0) > oldbrk)
+    sbrk(-(sbrk(0) - oldbrk));
+
+  printf(stdout, "sbrk test OK\n");
+}
+
+void
+validateint(int *p)
+{
+  int res;
+  asm("mov %%esp, %%ebx\n\t"
+      "mov %3, %%esp\n\t"
+      "int %2\n\t"
+      "mov %%ebx, %%esp" :
+      "=a" (res) :
+      "a" (SYS_sleep), "n" (T_SYSCALL), "c" (p) :
+      "ebx");
+}
+
+void
+validatetest(void)
+{
+  int hi, pid;
+  uint p;
+
+  printf(stdout, "validate test\n");
+  hi = 1100*1024;
+
+  for(p = 0; p <= (uint)hi; p += 4096){
+    if((pid = fork()) == 0){
+      // try to crash the kernel by passing in a badly placed integer
+      validateint((int*)p);
+      exit();
+    }
+    sleep(0);
+    sleep(0);
+    kill(pid);
+    wait();
+
+    // try to crash the kernel by passing in a bad string pointer
+    if(link("nosuchfile", (char*)p, 1) != -1){
+      printf(stdout, "link should not succeed\n");
+      exit();
+    }
+  }
+
+  printf(stdout, "validate ok\n");
+}
+
+// does unintialized data start out zero?
+char uninit[10000];
+void
+bsstest(void)
+{
+  int i;
+
+  printf(stdout, "bss test\n");
+  for(i = 0; i < sizeof(uninit); i++){
+    if(uninit[i] != '\0'){
+      printf(stdout, "bss test failed\n");
+      exit();
+    }
+  }
+  printf(stdout, "bss test ok\n");
+}
+
+// does exec do something sensible if the arguments
+// are larger than a page?
+void
+bigargtest(void)
+{
+  int pid, ppid;
+
+  ppid = getpid();
+  pid = fork();
+  if(pid == 0){
+    char *args[32+1];
+    int i;
+    for(i = 0; i < 32; i++)
+      args[i] = "bigargs test: failed\n                                                                                                                     ";
+    args[32] = 0;
+    printf(stdout, "bigarg test\n");
+    exec("echo", args);
+    printf(stdout, "bigarg test ok\n");
+    exit();
+  } else if(pid < 0){
+    printf(stdout, "bigargtest: fork failed\n");
+    exit();
+  }
+  wait();
+}
+
+int
+main(int argc, char *argv[])
+{
+  printf(1, "usertests starting\n");
+
+  if(open("usertests.ran", 0) >= 0){
+    printf(1, "already ran user tests -- rebuild fs.img\n");
+    exit();
+  }
+  close(open("usertests.ran", O_CREATE));
+
+  bigargtest();
+  bsstest();
+  sbrktest();
+  validatetest();
+
+  opentest();
+  writetest();
+  writetest1();
+  createtest();
+
+  mem();
+  pipe1();
+  preempt();
+  exitwait();
+
+  rmdot();
+  fourteen();
+  bigfile();
+  subdir();
+  concreate();
+  linktest();
+  unlinkread();
+  createdelete();
+  twofiles();
+  sharedfd();
+  dirfile();
+  iref();
+  forktest();
+  bigdir(); // slow
+
+  exectest();
+
+  exit();
+}
diff -uNr xv6.orig/wc.c xv6/wc.c
--- xv6.orig/wc.c	2011-02-28 11:32:48.000000000 -0300
+++ xv6/wc.c	2011-12-04 16:28:48.000000000 -0200
@@ -43,7 +43,7 @@
   }
 
   for(i = 1; i < argc; i++){
-    if((fd = open(argv[i], 0)) < 0){
+    if((fd = open(argv[i], 0, 0)) < 0){
       printf(1, "cat: cannot open %s\n", argv[i]);
       exit();
     }
